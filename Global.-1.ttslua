--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ --]]
--Steam Workshop ID : 814121724
--Authors: ITzMeek & DejMan
--Date: 12-09-2019
--TTS Build: v12.0

debugging = false`

--[[GUID Static References]]
startingDeck_GUID = "18c2e8"
playMatt_GUID = "f82f1f"
rotationMatt_GUID = "7b482f"
playDeckZone_GUID = "600b0b"
drawDeckZone_GUID = "45f602"
--[[Object References]]
drawDeckZone = nil
playDeckZone = nil
drawDeckObject = nil
playDeckObject = nil
playMattObject = nil
rotationMattObject = nil

--[[String Variables That Are Used For Different Messages In The UI]]--
Waiting_For_Game_Start_Message="Waiting For The Host (%s) To Start The Game"
Waiting_For_Stacking_Message="Waiting For %s To Stack A Card, Or Draw Cards"
Waiting_For_Wild_Card_Message="Waiting For %s To Pick A Color"
Waiting_For_Trade_Message="Waiting For %s To Trade Their Cards"

--[[Table used to get quick references of the player colors in this game mode]]
PLAYERS = {
Player.Green,
Player.Blue,
Player.Purple,
Player.Pink,
Player.White,
Player.Red,
Player.Orange,
Player.Yellow}
--[[Static reference of world locations in the world for where the player label token should be located for a given player]]
TOKENLOCATIONS = {
    ["GREEN"]  = {   0,    1.5,    9},
    ["BLUE"]   = { 6.36,   1.5, 6.36},
    ["PURPLE"] = {   9,    1.5,    0},
    ["PINK"]   = { 6.36,   1.5,-6.36},
    ["WHITE"]  = {    0,   1.5,   -9},
    ["RED"]    = {-6.36,   1.5,-6.36},
    ["ORANGE"] = {   -9,   1.5,    0},
    ["YELLOW"] = {-6.36,   1.5, 6.36}}
--[[Static reference of rotations to keep the player label token facing outward for each given player]]
TOKENROTATIONS = {
    ["GREEN"]  = {    0, 180,    0},
    ["BLUE"]   = {    0, 225,    0},
    ["PURPLE"] = {    0, 270,    0},
    ["PINK"]   = {    0, 315,    0},
    ["WHITE"]  = {    0, 360,    0},
    ["RED"]    = {    0,  45,    0},
    ["ORANGE"] = {    0,  90,    0},
    ["YELLOW"] = {    0, 135,    0}}

DRAWBUTTONLOCATIONS = {
    ["TOP"]     = { -2, 1.2,   2.3},
    ["BOTTOM"]  = { -2, 1.2,  -2.3},
    ["SCALE"]   = { 1.5, 1.5, 1.5}}
YIELDSTATE = {
    ["STACK"] = "stacking",
    ["WILD"] = "wild",
    ["TRADE"] = "Trade"}
--[[Runtime tables that will only populate with the data needed for the given players]]
drawButtons = {}
tokenLocations = {}
tokenRotations = {}
players = {}

startingCardNumber = 7
showMainMenu = false    
gameStart = false
tokenObject = nil
gameRoom_Admin = nil
currentPlayer_Label = nil
currentPlayer = nil       --Responsible for keeping reference of the current player
currentPlayer_Index = nil --Easy reference of the *index* of the current player in the 'players' table
currentPlayer_Label = nil --Easy reference of the current player's Steam name
playerOne_Index = nil
lastPlayer = nil          --Responsible for keeping track of the last player that went
lastCard_Name = nil       --Responsible for keeping track of the name of the last played card
lastCard_Desc = nil       --Responsible for keeping track of the description of the last played card
nextPlayer = nil          --Responsible for keeping reference of the next player in order
nextPlayer_index = nil    --Easy reference of the *index* of the next player in the 'players' table
clockwisePlay = true      --Responsible for keeping track of clockwise or coutner-clockwise play direction
stackingCounter = 0       --Keeps track of how many cards a player must draw for a +2 or +4
enableStacking = false    --Keeps track of if 'allow all stacking' rule
enableP2Stacking = false  --Keeps track of if 'allow +2 stacking' rule
enableP4Stacking = false  --Keeps track of if 'allow +4 stacking' rule
enableSevenZeroRules = false --Keeps track of if 'allow 7-0' rule
playerIsStack = false     --Keeps track of if a player is stacking draw cards or not
drawOneCard = true
cardDrawn = false
allowTurnPassing = true
passButtonShown = false

winCondition = false      --Responsible for keeping track of if a win condition has been met
decksFlipped = false
MenuDefaults = true     --Used to set the Main Menu options to their default states

gameloopCoroutine = nil
yieldState = nil





---------------------------------------------------------------------------------------------------------------------------
--EVENT FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[ The onUpdate event is called once per frame. --]]
function onUpdate()
end--Function onUpdate END

--[[ The onLoad event is called after the game save finishes loading. --]]
function onLoad()

    UI.setValue("Selection","Testing")
    --Set references to the static objects in our game
    drawDeckZone = getObjectFromGUID(drawDeckZone_GUID)
    playDeckZone = getObjectFromGUID(playDeckZone_GUID)
    drawDeckObject = getObjectFromGUID(startingDeck_GUID)
    playMattObject = getObjectFromGUID(playMatt_GUID)
    rotationMattObject = getObjectFromGUID(rotationMatt_GUID)
    --Reset the color tint to the PlayMat and Rotation Mat, just to be safe
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})
    --Disable interaction with Key objects to avoid players messing things up
    if(debugging == false)
    then
      drawDeckObject.interactable = false
      playMattObject.interactable = false
      rotationMattObject.interactable = false
      rotationMattObject.setLock(true)
    end
    --Update our reference table to the players that are seated
    UpdatePlayerTable()
    --Reset any key variables, just to be safe
    playerIsStacking = false
    
    --Init certain UI elements
        --Because we manipulate the "visibilty" tag on these elements later, we need to keep them active, but hide them
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")

    --ToggleHandTradeButtons(true)

    --Init the Message Panel and Starting Player Button
    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
    --We default the Player One button to the Game Admin just for simplicity
    UI.setAttribute("playerOneButton", "Text", gameRoom_Admin.steam_name)
    UI.setAttribute("playerOneButton", "Color", gameRoom_Admin.color)

end--Function onLoad END

function onPlayerChangedColor(player_color)
    if gameStart == true
    then
        if player_color ~= "Grey"
        then
            ClearHands(false)

            if player_color ~= "Black"
            then
                if #Player[player_color].getHandObjects() == 0
                then
                    DealCardsToColor(7, player_color)
                end
            end
        end
    end
    UpdatePlayerTable()
end--Function onPlayerChangedColor END

--[[This function is primarily used to make sure players are not throwing cards out of their hands]]
function onObjectDrop(player_color,dropped_object)

    local cardDropped = true
    --First, we only care if the object a player is dropping is a card
    if dropped_object.tag == 'Card'
    then
        --We check the "Owner" of the dropped card, and compare it to the Player that dropped it
        if dropped_object.getVar("Owner") == Player[player_color]
        then
            --Using Wait.time() and an in-line function, we can execute the following code after a certain amount of time
            Wait.time(
            function ()
                --First we get a reference to if the card being dropped is being played
                local inPlay = dropped_object.getVar("CardInPlay")
                --We also get a reference to the player color for simplicity
                local _player = Player[player_color]

                --We check if the card being dropped is NOT being played
                if inPlay == false
                then
                    --What we do here is loop through all of the objects that are now in the players hands, to see if the card being dropped
                    --is being dropped into their hand, in which case no further action is needed
                    for i = 1 , #Player[player_color].getHandObjects(), 1
                    do--Loop through all the objects the player has picked up
                        if Player[player_color].getHandObjects()[i] == dropped_object
                        then
                            cardDropped = false
                        end
                    end
                    --At this point, if the card being dropped is NOT being played, and is NOT being dropped into their hand, we will assume
                    --The card is being dropped out in the open, and we should return the card to their hand
                    if cardDropped == true
                    then
                        dropped_object.setPosition({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})
                        dropped_object.setRotation({_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,_player.getPlayerHand()['rot_z']})
                        broadcastToColor("Please only leave your cards in the play zone", player_color, getColorValuefromPlayer(player_color))
                    end
                end
            end,--End In-Line Function
            0.2)--This function will execute 0.2 seconds after a card is dropped
        end
    end
end--Function onObjectDrop END

--[[This is mostly used to stop players from trying to play more than one card at a time]]
function onObjectPickUp(player_color, picked_up_object)
    --If the card being picked up does not belong to the player picking it up, or if the player is NOT the Game Master (Black seat) we need to force them to drop it
    if picked_up_object.getVar("Owner").color ~= Player[player_color].color and player_color ~= "Black"
    then
        picked_up_object.drop()
        broadcastToColor("Do Not Take Other Players Cards", player_color, getColorValuefromPlayer(player_color))
    end
end--Function onObjectPickUp END

--[[This handles the logic of when a player tries to put a card into play]]
function onObjectEnterScriptingZone(zone, enter_object)

    if enter_object.held_by_color ~= "Black"
    then--First we check if the object is being held by the Game Master, as we don't want to apply logic to their actions
        if winCondition == false
        then--Next we check if the game has already been won, as we no longer need to apply logic after that point
            if enter_object.getGUID() ~= tokenObject.getGUID()
            then--Next, we dismiss the player label token, as we don't ever care if it enters a cripting zone
                if zone.getGUID() == playDeckZone_GUID
                then--Next, we check that the zone is the PlayZone
                    if enter_object.tag == 'Card'
                    then--Next, we check if the object entering the play zone is a card
                        if enter_object.getGUID() ~= playmatt_GUID
                        then--Next, we check that the object entering the zone is NOT the playMatt
                            if enter_object.held_by_color ~= nil
                            then--Next, we check that the object being checked is held by a player
                                if currentPlayer ~= nil
                                then--We check to make sure that the game logic has determined the current player
                                    if enter_object.held_by_color == currentPlayer.color
                                    then--Next, we check that the player holding the object is the current player
                                        if #Player[enter_object.held_by_color].getHoldingObjects() == 1
                                        then--Next, we check that the player is only holding one object, to avoid cheating the game logic

                                        ---------------------------------------------------------------------------------------------------------------------------
                                        --At this point, We know that a card is being properly played, so we can handle some logic that applies to the card itself
                                        ---------------------------------------------------------------------------------------------------------------------------

                                            if gameloopCoroutine ~= nil
                                            then--First, Check if the gameloopCoroutine object is *not* empty (nil). The only time it should be empty is the very first turn of the game, so in that case we can skip a little bit of extra logic
                                                if coroutine.status(gameloopCoroutine) == "suspended"
                                                then--Here, we check if the 'gameloopCoroutine' is currently suspended, meaning the game logic is waiting on a form of input. This should only be the case if we are waiting for a player to respond to a wild or draw card
                                                    --To determine what time of input we are waiting on, we can check our yieldState variable
                                                    if yieldState == YIELDSTATE.STACK
                                                    then--Here we check our yieldstate for "stacking". If this is the case, we are waiting for a player to repsond to a stacking rule, and the only cards that are allowed to be played, are draw cards of the same type
                                                        if enter_object.getName() == lastCard_Name
                                                        then--So we check if the card being played is the same face-type as the last card played
                                                            CheckCard(enter_object)
                                                        else
                                                            RejectCard(enter_object,"You Must Play A Card That Stacks, Or Draw Cards")
                                                        end

                                                    elseif yieldState == YIELDSTATE.WILD
                                                    then--Here we check our yieldstate for "wild". If this is the case, no cards should be played, and the current Player needs to pick a color
                                                        RejectCard(enter_object, "You Must Pick A Wild Color")

                                                    elseif yieldState == YIELDSTATE.TRADE
                                                    then
                                                        RejectCard(enter_object, "You Must Decide Who To Trade Cards With")
                                                    end
                                                else--If our 'gameloopCoroutine' is *not* suspended, then there shouldn't be any special cards in play, and no special game logic is needed
                                                    CheckCard(enter_object)
                                                end
                                            else--If our 'gameLoopCoroutine' is empty(nil), we can assume that this is the first turn of play
                                                CheckCard(enter_object)
                                            end
                                        else--If the player is holding more than 1 card. This is a bit of legacy code, as technically there are other parts of the script that should make this impossible, but there's no harm in keeping it here
                                            RejectCard(enter_object, "You May Only Play One Card At A Time")
                                        end
                                    else--The player holding the object is not the Current Player
                                        RejectCard(enter_object,"It Is Not Your Turn Now")
                                    end
                                end
                            end
                        end
                    else--The object entering our PlayZone is NOT a card, but there are still some special cases we need to check for
                        if enter_object.tag ~= "Deck"
                        then
                            if enter_object ~= tokenObject
                            then
                                --The Deck and the Player Token will sometimes trigger out Play Zone, but we don't want to apply any logic to them. Anything else should not be allowed to enter the zone though
                                RejectObject(enter_object)
                            end
                        end
                    end
                end
            end
        end
    end
end--Funciton onObjectEnterScriptingZone END

---------------------------------------------------------------------------------------------------------------------------
--GAME LOGIC FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[This function handles anything that needs taken care of at the start of a round of UNO]]
function InitGame()

    currentPlayer = players[playerOne_Index]
    currentPlayer_Index = playerOne_Index
    --Hide the UI elements that are only used at the start of a game
    UI.setAttribute("MainMenuContainer", "active", "False")
    UI.setAttribute("MessagePanel", "active", "False")
    --UI.setAttribute("HideMenuButton", "active", "False")

    
    --Tell the players what order they are in
    ListPlayers()
    UpdatePlayerLabel()
    --Create Objects & Buttons for drawing from the deck
    drawButtons[0] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONLOCATIONS.BOTTOM,
        rotation          = {0,180,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[0].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = {0,0.1,0},
        rotation       = {0,0,0},
        scale          = DRAWBUTTONLOCATIONS.SCALE,
        width          = 1500,
        height         = 700,
        font_size      = 250,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})
    drawButtons[1] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONLOCATIONS.TOP,
        rotation          = {0,0,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[1].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = {0,0.1,0},
        rotation       = {0,0,0},
        scale          = DRAWBUTTONLOCATIONS.SCALE,
        width          = 1500,
        height         = 700,
        font_size      = 250,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})

    drawButtons[0].setLock(true)
    drawButtons[1].setLock(true)
    --Shuffle the deck
    drawDeckObject.shuffle()

    --Seed the first card
    drawDeckCards = drawDeckObject.getObjects()
    local counter = 0

    --We iterate through the draw pile until we find a card that is NOT a wild, to use as our starting play card
    repeat
        counter = counter + 1
    until drawDeckCards[counter].description ~= "WILD"

    playDeckObject = drawDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 1.5 , playDeckZone.getPosition()['z'] },
        rotation = { 0,180,0},
        index = counter-1,
        smooth =  false })

    lastCard_Name = playDeckObject.getName()
    lastCard_Desc = playDeckObject.getDescription()
    playMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))

    --Deal 7 cards to each seated player
    for i,player in ipairs(players)
    do
        DealCardsToColor(startingCardNumber, player.color)
    end

    Wait.time(
        function () UpdateDeckObjects() end,
        0.5)


    --tell the game logic that the game has started
    gameStart = true
end--Function InitGame END

--This function gives me nightmares
function REEset()

    --First we hide and reset any UI elements that are used during gameplay
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")
    UI.setAttribute("playerOneButton", "Text", currentPlayer.steam_name)
    UI.setAttribute("playerOneButton", "Color", currentPlayer.color)

    UpdatePlayerTable()--Update our reference to the seated players
    ToggleDrawButtons(false)--Hide our draw card buttons
    Wait.time(
      function()
        ClearHands(true)--clear out the cards out of players' hands, ignoring if a player is seated there
      end,
    1)


    --This function will reset the play and draw decks after 2 seconds
    Wait.time(
        function ()
            UpdateDeckObjects()
            playDeckObject.interactable = true
            playDeckObject.setRotation({180,180,0})
            playDeckObject.setPosition({drawDeckZone.getPosition()['x'] , 3 , drawDeckZone.getPosition()['z']})
            --playDeckObject = nil
            Wait.time(function () drawDeckObject.shuffle() end, 1)
            end,
        2)
    --This function will reset any key variables after 3 seconds
    Wait.time(
        function ()
            gameStart = false
            winCondition = false
            currentPlayer = nil
            currentPlayer_Index = nil
            lastPlayer = nil
            lastCard_Name = nil
            lastCard_Desc = nil
            gameloopCoroutine = nil
            playerIsStacking = false
        end,
        3)
    --This function will show the Show the Start Game UI elements after 4 seconds
    Wait.time(
        function ()
            UI.setAttribute("StartGameMenu", "active", "True")
            UI.setAttribute("MessagePanel", "active", "True")
            UI.setAttribute("MainMenuContainer", "active", "True")
            UI.show("MessagePanel")

            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
            UI.setAttribute("HideMenuButton", "visibility", "Host")
            UI.setAttribute("StartGameMenu", "visibility", "Host")
        end,
        4)
    --Reset the color tint of our Play Mat and Rotation Mat
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})

end--Function REEset END

--[[This function is called after we've determined that a card is allowed to be put into play. This makes sure that the card played is a playable card]]
function CheckCard(currentCard)
    if lastCard_Name == nil
    then -- We check ifthe lastCard_Name is empty(nil), meaning this is the first card in the pile
        PlayCard(currentCard)
    else -- Otherwise, we need to check our current card against the last card
        if currentCard.getDescription() == "WILD"
        then -- First, we check if the currentCard is a wild card. This means we don't need to check against the lastCard
            PlayCard(currentCard)
        elseif currentCard.getName() == lastCard_Name
        then -- This checks if currentCard has the same face value as lastCard
            PlayCard(currentCard)
        elseif currentCard.getDescription() == lastCard_Desc
        then -- this checks if currentCard has the same colorvalue as lastCard
            PlayCard(currentCard)
        else --this means that currentCard is not a playable card
            RejectCard(currentCard,"This Card Cannot Be Played")
        end
    end
end--Function CheckCard END

--[[This function is used to return an invalid card to the players hand]]
function RejectCard(currentCard, game_message)

    --Grab a quick reference to the player that is holding the card
    local _player = Player[currentCard.held_by_color]
    if game_message ~= ""
    then--If the game_message is *not* empty, broacast it to the player
        broadcastToColor(game_message, _player.color ,getColorValuefromPlayer(_player.color))
    end
    --send the currentCard back to the player's hand
    currentCard.setPositionSmooth({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})

end--Function RejectCard END

--[[The function is mostly used to stop non-card objects from entering the game zones]]
function RejectObject(obj)

    if obj.held_by_color ~= nil
    then
        broadcastToColor("This object does not belong in the playing card area", obj.held_by_color, getColorValuefromPlayer(obj.held_by_color))
    else
        broadcastToAll("An invalid object entered the playing card area", getColorValuefromPlayer(PLAYERS.WHITE))
    end

    local velocity = obj.getVelocity()
    obj.translate({
        ClampValue( -(math.floor(velocity.x*2)+5),-8,8),
        3,
        ClampValue( -(math.floor(velocity.z*2)+5),-8,8)})

end--Function RejectObject

--[[This function handles a little bit of logic when a card is being put into play, before we dive into our main Game Loop]]
function PlayCard(cardObj)

    cardObj.setRotationSmooth({0,180,0}, false, true)
    local FixedPos = playDeckZone.getPosition()
    cardObj.setPositionSmooth({FixedPos.x,3,FixedPos.z}, false, true)

    if #currentPlayer.getHandObjects() == 0 and winCondition == false
    then--If a player has no more cards in their hand after a card is played, a win condition has been met
        broadcastToAll(currentPlayer.steam_name .. " Has Played Their Last Card & Won The Round", getColorValuefromPlayer(currentPlayer.color))
        winCondition = true
        REEset()
    end

    --we set the card's "CardInPlay" variable to true now that it has entered the play deck
    cardObj.setVar("CardInPlay", true)
    if winCondition == false
    then--If the Win Condition has not yet been met, we can continue with our game play logic
        if gameloopCoroutine ~= nil
        then--if our Game Loop is not empty, then we need to resume it. This should only be the case for a wild card, or draw card, and our game logic up to this point has made sure the correct conditions have been met, and we can safely resume our Game Loop
            if coroutine.status(gameloopCoroutine) == "suspended"
            then
                coroutine.resume(gameloopCoroutine)
            end
        end
        --Update our references to the last card that has been played
        lastCard_Name = cardObj.getName()
        lastCard_Desc = cardObj.getDescription()

        if lastCard_Desc ~= "WILD"
        then--So long as the last card played is NOT a wild card, we should update our play matts to the correct color
            playMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))
            rotationMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))
        end

        --Start our Game Loop
        gameloopCoroutine = coroutine.create(GameLoop)
        coroutine.resume(gameloopCoroutine)

    end

end--Function PlayCard END

--[[Helper Function that can be given a Player Color and a number, to deal that many cards to that Player]]
function DealCardsToColor(count,color)
    for i=1, count
    do
        local dealtCard
        local _player = Player[color]
        --drawDeckObject.deal(1, color)
        dealtCard = drawDeckObject.takeObject({
            position = {_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']},
            rotation = {_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0},
            index = 1,
            smooth = false})

        dealtCard.setVar("Owner", _player)
        dealtCard.setVar("CardInPlay", false)
    end
end--Function DealCards END

--[[This function will clear out the cards a hand zone. Normally, this function will only clear hands that don't have a seated player, but can clear all hands if given a condition]]
function ClearHands(ignoreSeated)
    for i, player in ipairs(PLAYERS)
    do
        if player.seated == false or ignoreSeated == true
        then
            if #player.getHandObjects() > 0
            then
                deckPosition = { drawDeckObject.getPosition()['x'] , drawDeckObject.getPosition()['y'] + 0.5 , drawDeckObject.getPosition()['z'] }
                deckRotation = drawDeckObject.getRotation()
                for i, card in ipairs(player.getHandObjects())
                do
                    card.setRotation(deckRotation)
                    card.setPosition(deckPosition)
                end
                drawDeckObject.shuffle()
            end
        end
    end
end--Function ClearHands END

--[[This function will move players hands between one player, designated as a 'sender' and another player designated as a 'receiver'.
    To simply swap hands between the sender and the receiver, set 'Recursive' to 0 when calling. Otherwise the function is designed to exchange hands with the player to your right]]
function ChangeHands(sendingPlayer,sendingPlayerHand,receivingPlayer,Recursive)
    --Create a reference to the Hand of the receiving player
    receiversHand = {}
    receiversHand = receivingPlayer.getHandObjects()

        --Iterate through all of the objects (cards) in the sending players hands
        for j=1,#sendingPlayerHand
        do

            --First we set the owner of the card to be the receiving player
            sendingPlayerHand[j].setVar("Owner", receivingPlayer)

            --print("Receiver: " .. sendingPlayerHand[j].getName() .. " | " .. sendingPlayerHand[j].getVar("Owner").steam_name)

            --Then we move the card to the receiving players hand, and fix its rotation
            sendingPlayerHand[j].setPosition( receivingPlayer.getHandTransform()['position'] )
            sendingPlayerHand[j].setRotation({receivingPlayer.getPlayerHand()['rot_x'],receivingPlayer.getPlayerHand()['rot_y']+180,0})
        end
        --If Recursive is greater than 1, we will assume we are exchanging cards with the player to your right, instead of just swapping hands with 1 other player
        if Recursive > 1
        then
            --decrease Recusive by 1
            Recursive = Recursive-1
            --Call this function again, but with the receiving player now becoming the sender, and the next player in line being the new receiver
            ChangeHands(receivingPlayer,receiversHand, players[ getIndexFromPlayer(receivingPlayer.color) % #players +1] , Recursive )

        --If Recursive is equal to 0, we assume we only want to swap hands between the sender and the receiver
        elseif Recursive == 0
        then
            --Call this function again, but with the receiver being the new sender, the sender being the new receiver, and Recursive as -1 to bypass this check again
            ChangeHands(receivingPlayer,receiversHand,sendingPlayer,-1)        
        end
end--Function ChangeHands END

--[[This function is responsible for update both the Current Player token that moves around the board, and the Current Player UI element]]
function UpdatePlayerLabel(token)

    local tokenLocation
    local tokenLabel
    local tokenColor
    local tokenRotation

    if currentPlayer ~= nil
    then
        tokenLocation = getTokenLocation(currentPlayer.color)
        tokenLabel = ("Current Player:\n%s"):format(currentPlayer.steam_name)
        tokenColor = currentPlayer.color
        tokenRotation = getTokenRotation(currentPlayer.color)
    else
        tokenLocation = getTokenLocation(Player.Black.color)
        tokenLabel = "No Player One"
        tokenColor = Player.Black.color
        tokenRotation = getTokenRotation(Player.Black.color)
    end

    if tokenObject == nil
    then
        tokenObject = spawnObject({
        type              = "PiecePack_Suns",
        position          = tokenLocation,
        rotation          = {0,0,0},
        scale             = {0.8,0.8,0.8},
        callback_fucntion = "dummyFunction",
        sound             = false})
    end


    tokenObject.interactable = false
    tokenObject.setColorTint(getColorValuefromPlayer(tokenColor))
    tokenObject.setPositionSmooth(tokenLocation,false,false)
    tokenObject.setRotation(tokenRotation)

    UI.setAttribute("PlayerLabel", "active", "True")
    UI.setAttribute("PlayerLabel", "text", tokenLabel)

    if tokenObject.UI.getXml() ~= ""
    then
        tokenObject.UI.setAttribute("PlayerLabel", "text", tokenLabel)
    else
        tokenObject.UI.setXmlTable(
        {
            {
                tag="HorizontalLayout",
                attributes=
                {
                    height=600,
                    width=1000,
                    position="0 0 -10",
                    color="rgba(0,0,0,0)",
                },
                children=
                {
                    {
                        tag="Text",
                        attributes=
                        {
                            id="PlayerLabel",
                            text= tokenLabel,
                            fontSize="130",
                            color= "white",
                            outline="black",
                            outlineSize="4 4"
                        },
                    },
                }
            }
        })
    end
end--Function UpdatePlayerLabel END

--[[This function broacasts what players are in what order, starting with player 1]]
function ListPlayers()

    --First we make sure to update our reference of seated players
    UpdatePlayerTable()

    local counter = 0

    for i = 1,#players,1
    do
        if currentPlayer~= nil
        then
            broadcastToAll(players[(currentPlayer_Index + counter)].steam_name .. " is player " .. i, getColorValuefromPlayer(players[(currentPlayer_Index+counter)].color))
            if (currentPlayer_Index + counter + 1) <= #players
            then
                counter = counter + 1
            else
                counter = (-currentPlayer_Index)+1
            end
        end
    end
end--Function ListPlayers END

--[[This function is called when one of the Draw Card buttons are clicked]]
function DrawCard(obj,color)

    if winCondition == false
    then
        if color ~= nil and color ~= "Black"
        then
            if color == currentPlayer.color
            then
                if yieldState == YIELDSTATE.STACK
                then
                    broadcastToColor("You Can Not Draw A Card At This Time",color, getColorValueFromPlayer(color))
                elseif yieldState == YIELDSTATE.WILD
                then
                    broadcastToColor("You Can Not Draw A Card At This Time", color, getColorValueFromPlayer(color))
                else
                    --Logic to show the "End Turn" button if that rule is enabled
                    if allowTurnPassing == true
                    then
                        if passButtonShown == false
                        then
                            UI.show("PassButtonPanel")
                            passButtonShown = true
                            UI.setAttribute("PassButtonPanel", "visibility", currentPlayer.color)
                        end
                    end
                    if drawOneCard == true and cardDrawn == true
                    then
                        broadcastToColor("You May Only Draw One Card per Turn. Play A Card, or Pass", currentPlayer.color,getColorValuefromPlayer(currentPlayer.color))
                        return
                    else
                        DealCardsToColor(1, color)
                        UpdateDeckObjects()
                        cardDrawn = true
                    end
                end
            end
        end
    end
end--Function DrawCard END

--updates the reference to 'gameRoom_Admin' 'players' 'tokenLocations' & 'tokenRotations' based on the players seated at the table
function UpdatePlayerTable()
    local counter = 1

    --Empty our reference tables
    players = {}
    tokenLocations = {}
    tokenRotations = {}

    if Player.Black.seated
    then
        if Player.Black.admin
        then
        gameRoom_Admin = Player.Black
        end
    end

    for i, _player in ipairs(PLAYERS)
    do--Go through our static PLAYERS table

        if _player.admin
        then--Check if the player is the host or a promoted player
            gameRoom_Admin=_player
            if currentPlayer == nil
            then--For simplicity, if the currentPlayer is not set, we set it to the admin
            currentPlayer = _player
            currentPlayer_Index = counter
            playerOne_Index = counter
            end
        end
        if _player.seated
        then--If a given player is seated
            players[counter] = _player--add that player to our reference table, and update our tokenLocations table
            tokenLocations[counter] = getTokenLocation(i)
            counter = counter + 1
        end
    end

    if currentPlayer ~= nil
    then
        if #players > 0
        then
            if currentPlayer.seated == false
            then
                currentPlayer = players[#players]
                currentPlayer_Index = #players
            end
        end
    end

end--Function UpdatePlayerTable END

--This function keeps our references to the draw and play deck objects up to date, and will reset the play deck when the draw deck becomes too small
function UpdateDeckObjects()

    playZoneObjects = playDeckZone.getObjects()
    drawDeckCards = drawDeckObject.getObjects()


    if decksFlipped == true
    then
        --Shuffle Deck twice because why not?
        drawDeckObject.shuffle()
        drawDeckObject.shuffle()
        decksFlipped = false
    end

    for i, v in pairs(playZoneObjects)
    do
        if v.tag == "Deck"
        then
            playDeckObject = v
            playDeckObject.interactable = false
        end
    end

    --Re-Establish the deck objects interactable status]
    if drawDeckObject then
        if debugging == false then
            drawDeckObject.interactable = false
        end
    end
    if playDeckObject then 
        if debugging == false then
            playDeckObject.interactable = false
        end
    end

    if #drawDeckCards < 18
    then
        playDeckObject.interactable = true
        playDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 2.8 , playDeckZone.getPosition()['z'] },
        index = #playDeckObject.getObjects()-1,
        smooth = true })
        playDeckObject.flip()
        playDeckObject.setPositionSmooth({drawDeckObject.getPosition()['x'],drawDeckObject.getPosition()['y']+2,drawDeckObject.getPosition()['z']}, false, true)
        decksFlipped = true

        Wait.time(
            function () UpdateDeckObjects() end,
            1.0)
    end
end--Function UpdateDeckObjects END

--[[Calculates the next currentPlayer & currentPlayer_Index in order and establishes lastPlayer]]
function NextPlayer()

    if clockwisePlay
    then
        if currentPlayer_Index + 1 > #players
        then
            currentPlayer_Index = 1
        else
            currentPlayer_Index = currentPlayer_Index + 1
        end
    else
        if currentPlayer_Index - 1 < 1
        then
            currentPlayer_Index = #players
        else
            currentPlayer_Index = currentPlayer_Index - 1
        end
    end

    lastPlayer = currentPlayer
    currentPlayer = players[currentPlayer_Index]
    cardDrawn = false

    UpdatePlayerLabel()

    UI.hide("PassButtonPanel")
    passButtonShown = false

    Wait.time(
        function ()
            UpdateDeckObjects()
        end,
        0.75)

end--Function NextPlayer END

--[[This is the function that does most of the logic for special cards]]
function GameLoop()


    if lastCard_Name == "reverse"
    then--Check if the card played was a reverse.
        clockwisePlay = not clockwisePlay
        rotationMattObject.setLock(false)
        if clockwisePlay == false then 
            rotationMattObject.setRotation({0,0,180}) 
        end

        if clockwisePlay == true then 
            rotationMattObject.setRotation({0,0,0}) 
        end

        if #players == 2
        then
            NextPlayer()
        end
        rotationMattObject.setLock(true)
    end

    NextPlayer()

    if lastCard_Name == "skip"
    then--Check if the card played was a skip
        NextPlayer()
    end

    if lastCard_Name == "+2"
    then--Check if the card played was a +2 card
        --Add To Our Stack Counter
        stackingCounter = stackingCounter + 2
        if enableStacking == true or enableP2Stacking == true
        then --Check if the game rules allow stacking +2 cards
        --Update Appropriate UI Elemtents
        UI.show("StackingCardPanel")
        UI.show("MessagePanel")
        UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
        UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
        ToggleDrawButtons(false)

        UI.setAttribute("StackingCardPanelText01", "Text", "Stack On Another +2 Card")
        UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
        --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
        --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
        --it will resume the coroutine at this point, and the playerIsStacking will still be true
        playerIsStacking = true
        yieldState = YIELDSTATE.STACK
        coroutine.yield()
        end

        if playerIsStacking == false
        then
            --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
            --print("Not Stacking ", stackingCounter , " | ", currentPlayer.color)
            DealCardsToColor(stackingCounter, currentPlayer.color)
            stackingCounter = 0

            NextPlayer()
        else
            return
        end
    end

    if lastCard_Desc == "WILD"
    then--Check if the card played was a wild card
        UI.show("WildCardPanel")
        UI.show("MessagePanel")
        UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Wild_Card_Message):format(lastPlayer.steam_name))
        UI.setAttribute("WildCardPanel", "visibility", lastPlayer.color)

        ToggleDrawButtons(false)

        yieldState = YIELDSTATE.WILD
        coroutine.yield()

        if lastCard_Name == "+4"
        then
            --Add To Our Stack Counter
            stackingCounter = stackingCounter + 4

            if enableStacking == true or enableP4Stacking == true
            then
                --Update Appropriate UI Elemtents
                UI.show("StackingCardPanel")
                UI.show("MessagePanel")
                UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
                UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
                ToggleDrawButtons(false)

                UI.setAttribute("StackingCardPanelText01", "Text", "Stack On Another +4 Wild Card")
                UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
                --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
                --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
                --it will resume the coroutine at this point, and the playerIsStacking will still be true
                playerIsStacking = true
                yieldState = YIELDSTATE.STACK
                coroutine.yield()
            end

            if playerIsStacking == false
            then
                --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                --print("Not Stacking ", stackingCounter , " | ", currentPlayer.color)
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0

                NextPlayer()
            else
                return
            end
        end
    end

    if allowSevenZeroRules == true
    then
        if lastCard_Name == "7"
        then
            UI.show("MessagePanel")
            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Trade_Message):format(lastPlayer.steam_name) )
            UI.setAttribute("HandSwappingPanel", "visibility", lastPlayer.color)
            ToggleDrawButtons(false)
            ToggleHandTradeButtons(true)
            
            yieldState = YIELDSTATE.TRADE
            coroutine.yield()

            ToggleHandTradeButtons(true)


        end

        if lastCard_Name == "0"
        then
            broadcastToAll(lastPlayer.steam_name .. " is rotating the table's hands", {1,1,1} )
            ChangeHands(lastPlayer,lastPlayer.getHandObjects(),currentPlayer,#players+1)
        end
    end



    yieldState = nil
    --print("Turn Complete")
end--function GameLoop END

---------------------------------------------------------------------------------------------------------------------------
--UI RELATED FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------


--[[This function is called when the "Don't Stack" button is click from the stacking card UI panel]]
function StackingPanelButtons()

    playerIsStacking = false
    coroutine.resume(gameloopCoroutine)

    UI.hide("StackingCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function StackingPanelButtons END

--[[This function is called by the buttons from the Wild Card UI panel]]
function WildPanelButtons(a,b, ID)
    if ID == "WildButtonRed"
    then
        lastCard_Desc = "RED"
    elseif ID == "WildButtonBlue"
    then
        lastCard_Desc = "BLUE"
    elseif ID == "WildButtonYellow"
    then
        lastCard_Desc = "YELLOW"
    elseif ID == "WildButtonGreen"
    then
        lastCard_Desc = "GREEN"
    end

    broadcastToAll("The Color Is Now ".. lastCard_Desc, getColorValuefromCard(lastCard_Desc))
    playMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValuefromCard(lastCard_Desc))
    coroutine.resume(gameloopCoroutine)

    UI.hide("WildCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function WildPanelButtons END

--[[This function is called by the buttons from the Trade Hands UI panel]]
function HandTradeButtons(a,b,ID)

    other_Player = nil
    
    if ID == "Player_White"
    then
        print(a.steam_name .. " wants to trade hands with White")
        other_Player=Player.White
    elseif ID == "Player_Red"
    then
        print(a.steam_name .. " wants to trade hands with Red")
        other_Player=Player.Red
    elseif ID == "Player_Orange"
    then
        print(a.steam_name .. " wants to trade hands with Orange")
        other_Player=Player.Orange
    elseif ID == "Player_Yellow"
    then
        print(a.steam_name .. " wants to trade hands with Yellow")
        other_Player=Player.Yellow
    elseif ID == "Player_Green"
    then
        print(a.steam_name .. " wants to trade hands with Green")
        other_Player=Player.Green
    elseif ID == "Player_Blue"
    then
        print(a.steam_name .. " wants to trade hands with Blue")
        other_Player=Player.Blue
    elseif ID == "Player_Purple"
    then
        print(a.steam_name .. " wants to trade hands with Purple")
        other_Player=Player.Purple
    elseif ID == "Player_Pink"
    then
        print(a.steam_name .. " wants to trade hands with Pink")
        other_Player=Player.Pink
    elseif ID == "No_Trade"
    then
        print(a.steam_name .. " Doesn't Want To Trade Hands")
    end

    if other_Player != nil
    then
        ChangeHands(a,a.getHandObjects(),other_Player,0)
        broadcastToAll("" .. a.steam_name .. " is trading their hand with " .. other_Player.steam_name,{1,1,1} )
    end

    

    coroutine.resume(gameloopCoroutine)

    UI.setAttribute("HandSwappingPanel", "Active", "false")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function HandTradeButtons END

--[[This function is used to show or hide the hand trading buttons]]
function ToggleHandTradeButtons(value)
    
    if value == true
    then
        UI.setAttribute("HandSwappingPanel", "active", "true")
        for i, _player in ipairs(PLAYERS)
        do

            if _player == Player.White
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_White", "Interactable", "true")
                    UI.setAttribute("Player_White", "Text", _player.steam_name)
                    
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_White", "Interactable", "false")
                        UI.setAttribute("Player_White", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_White", "Interactable", "false")
                    UI.setAttribute("Player_White", "Text", "Not Seated")
                end
            elseif _player == Player.Red
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Red", "Interactable", "true")
                    UI.setAttribute("Player_Red", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Red", "Interactable", "false")
                        UI.setAttribute("Player_Red", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Red", "Interactable", "false")
                    UI.setAttribute("Player_Red", "Text", "Not Seated")
                end
            elseif _player == Player.Orange
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Orange", "Interactable", "true")
                    UI.setAttribute("Player_Orange", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Orange", "Interactable", "false")
                        UI.setAttribute("Player_Orange", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Orange", "Interactable", "false")
                    UI.setAttribute("Player_Orange", "Text", "Not Seated")
                end
            elseif _player == Player.Yellow
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Yellow", "Interactable", "true")
                    UI.setAttribute("Player_Yellow", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Yellow", "Interactable", "false")
                        UI.setAttribute("Player_Yellow", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Yellow", "Interactable", "false")
                    UI.setAttribute("Player_Yellow", "Text", "Not Seated")
                end
            elseif _player == Player.Green
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Green", "Interactable", "true")
                    UI.setAttribute("Player_Green", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Green", "Interactable", "false")
                        UI.setAttribute("Player_Green", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Green", "Interactable", "false")
                    UI.setAttribute("Player_Green", "Text", "Not Seated")
                end
            elseif _player == Player.Blue
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Blue", "Interactable", "true")
                    UI.setAttribute("Player_Blue", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Blue", "Interactable", "false")
                        UI.setAttribute("Player_Blue", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Blue", "Interactable", "false")
                    UI.setAttribute("Player_Blue", "Text", "Not Seated")
                end
            elseif _player == Player.Purple
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Purple", "Interactable", "true")
                    UI.setAttribute("Player_Purple", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Purple", "Interactable", "false")
                        UI.setAttribute("Player_Purple", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Purple", "Interactable", "false")
                    UI.setAttribute("Player_Purple", "Text", "Not Seated")
                end
            elseif _player == Player.Pink
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Pink", "Interactable", "true")
                    UI.setAttribute("Player_Pink", "Text", _player.steam_name)
                    if _player == lastPlayer
                    then
                        UI.setAttribute("Player_Pink", "Interactable", "false")
                        UI.setAttribute("Player_Pink", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Pink", "Interactable", "false")
                    UI.setAttribute("Player_Pink", "Text", "Not Seated")
                end
            end

        end
    elseif value == false
    then
        UI.setAttribute("HandSwappingPanel", "active", "false")   
    end

end--Function ToggleHandTradeButtons END

--[[This function is used to show or hide the draw card buttons]]
function ToggleDrawButtons(value)
    if value == false
    then
        drawButtons[0].setScale({0,0,0})
        drawButtons[1].setScale({0,0,0})
    else
        drawButtons[0].setScale({0.5,0.5,0.5})
        drawButtons[1].setScale({0.5,0.5,0.5})
    end
end--Function ToggleDrawButtons END

--[[This function is called by the Hide/Show menu button and should be self explanatory]]
function ToggleStartMenu(value)

    if UI.getAttribute("StartGameMenu", "active") == "true"
    then
        UI.setAttribute("StartGameMenu", "active", "false")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,0)")
        UI.setAttribute("MainMenuContainer", "height", "5%")
        UI.setAttribute("MainMenuContainer", "width", "15%")
        UI.setAttribute("HideMenuButton", "text", "Show Main Menu")
        UI.setAttribute("HideMenuButton", "height", "100%")

    else
        UI.setAttribute("StartGameMenu", "active", "true")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,1)")
        UI.setAttribute("MainMenuContainer", "height", "90%")
        UI.setAttribute("MainMenuContainer", "width", "50%")
        UI.setAttribute("HideMenuButton", "text", "Hide Main Menu")
        UI.setAttribute("HideMenuButton", "height", "5%")
    end

end--Function ToggleStartMenu END

--[[This function is called by the Draw Deck Rule Toggle Butttons from the Main Menu]]
function CardDrawingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "drawOneCard"
        then
            drawOneCard = true
            UI.setAttribute("TurnPassingRuleRow", "active", "False")
        elseif id == "drawManyCards"
        then
            drawOneCard = false
            UI.setAttribute("TurnPassingRuleRow", "active", "True")
        end
    end

end--Function CardDrawingRuleChange

--[[This function is called by the "Allow Turn Passing" buttons from the Main Menu]]
function TurnPassingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "allowPassing"
        then
            allowTurnPassing = true
        elseif id == "noPassing"
        then
            allowTurnPassing = false
        end
    end

end--Function CardDrawingRuleChange

--[[This function is called by the Stacking Rule Toggle Buttons from the Main Menu]]
function StackingRuleChange(n , value, id)

    if value == "True"
    then--First we check if value is true, meaning we are only listening to the buttons that have been toggled on
        if id == "noStackToggle"
        then--If 'Dont Stack Cards' has been chosen
            enableStacking = false
            enableP2Stacking = false
            enableP4Stacking = false
        elseif id == "allStackToggle"
        then--If 'Stack +2 and +4 Cards' has been chosen
            enableStacking = true
            enableP2Stacking = false
            enableP4Stacking = false
        elseif id == "p2StackToggle"
        then--If 'Only Stack +2 Cards' has been chosen
            enableStacking = false
            enableP2Stacking = true
            enableP4Stacking = false
        elseif id == "p4StackToggle"
        then--if 'Only Stack +4 Cards' has been chosen
            enableStacking = false
            enableP2Stacking = false
            enableP4Stacking = true
        end
    end

end--Function StackingRuleChange END

--[[This function is called by the 7-0 Rule Toggle Button from the Main Menu]]
function SevenZeroRuleChange(n, value, id)

    if value == "True"
    then
       allowSevenZeroRules = true
    else
        allowSevenZeroRules = false 
    end
end

--[[This function is called by the "Pick Player One" element from the Main Menu, and is used to pick the first player in order]]
function PickPlayerOne(obj,color)

    if color ~= "Black"
    then
        if playerOne_Index + 1 > #players
        then
            playerOne_Index = 1
        else
            playerOne_Index = playerOne_Index + 1
        end
        UI.setAttribute("playerOneButton", "text", players[playerOne_Index].steam_name )
        UI.setAttribute("playerOneButton", "color", players[playerOne_Index].color)
    end

end--Function PickPlayerOne END

---------------------------------------------------------------------------------------------------------------------------
--HELPER FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[Helper Function to return the index a player color is in the 'players' table that keeps track of currently seated players]]
function getIndexFromPlayer(player_color)
    for i=1,#players
    do
        if players[i].color == player_color
        then
            return i
        end
    end
end

--[[Helper Function to return a color code give a PLAYERS color string]]
function getColorValuefromPlayer (player_color)
    if player_color == "Green"
    then
        return {0.129,0.701,0.168}

    elseif player_color == "Blue"
    then
        return {0.118, 0.53, 1}

    elseif player_color == "Purple"
    then
        return {0.627, 0.125, 0.941}

    elseif player_color == "Pink"
    then
        return {0.96, 0.439, 0.807}

    elseif player_color == "White"
    then
        return {1, 1, 1}

    elseif player_color == "Red"
    then
        return {0.856, 0.1, 0.094}

    elseif player_color == "Orange"
    then
        return {0.956, 0.392, 0.113}

    elseif player_color == "Yellow"
    then
        return {0.905, 0.898, 0.172}

    elseif player_color == "Grey"
    then
        return {0.5, 0.5, 0.5}

    elseif player_color == "Black"
    then
        return {0.25, 0.25, 0.25}

    end

end--Function getColorValueFromPlayer END

--[[Helper Function to return a color code given a card color string]]
function getColorValuefromCard (card_color)

    if card_color == "GREEN"
    then
        return {0.129,0.701,0.168}
    end

    if card_color == "BLUE"
    then
        return {0.118, 0.53, 1}
    end

    if card_color == "RED"
    then
        return {0.856, 0.1, 0.094}
    end

    if card_color == "YELLOW"
    then
        return {0.905, 0.898, 0.172}
    end

end--Function getColorValuefromCard END

--[[Helper Function to return the apropriate TOKENPOSITION vector given a PLAYERS color string]]
function getTokenLocation(color)

    if color == "Green"
    then
        return TOKENLOCATIONS.GREEN
    elseif color == "Blue"
    then
        return TOKENLOCATIONS.BLUE
    elseif color == "Purple"
    then
        return TOKENLOCATIONS.PURPLE
    elseif color == "Pink"
    then
        return TOKENLOCATIONS.PINK
    elseif color == "White"
    then
        return TOKENLOCATIONS.WHITE
    elseif color == "Red"
    then
        return TOKENLOCATIONS.RED
    elseif color == "Orange"
    then
        return TOKENLOCATIONS.ORANGE
    elseif color == "Yellow"
    then
        return TOKENLOCATIONS.YELLOW
    elseif color == "Black"
    then
        return TOKENLOCATIONS.WHITE
    end

end--Function getTokenLocation END

--[[Helper Function to return the appropriate TOKENROATIONS vector given a PLAYERS color string]]
function getTokenRotation(color)

    if color == "Green"
    then
        return TOKENROTATIONS.GREEN
    elseif color == "Blue"
    then
        return TOKENROTATIONS.BLUE
    elseif color == "Purple"
    then
        return TOKENROTATIONS.PURPLE
    elseif color == "Pink"
    then
        return TOKENROTATIONS.PINK
    elseif color == "White"
    then
        return TOKENROTATIONS.WHITE
    elseif color == "Red"
    then
        return TOKENROTATIONS.RED
    elseif color == "Orange"
    then
        return TOKENROTATIONS.ORANGE
    elseif color == "Yellow"
    then
        return TOKENROTATIONS.YELLOW
    elseif color == "Black"
    then
        return TOKENROTATIONS.WHITE
    end

end--Function getTokenRotation END

--[[Helper Function to clamp the value between the min value and the max value]]
function ClampValue(value,min,max)
    if value < min
    then
        value = min
    end

    if value > max
    then
        value = max
    end

    return value
end--Function ClampValue END


--[[Debug function to print the arguments passed from the caller. Helpful to findout what information is passed from object events or callback functions]]
function DebugFunction(a, b, c, d, e)
    print("Debug Print: ", a , " | ", b ," | ", c, " | ", d, " | ", e)
end--Function DebugFunction END